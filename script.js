function processText() {
    const inputField = document.getElementById('input');
    let text = inputField.value;

    if (!text) return;

    // --- 0. Remove AI Watermarks & Artifacts ---
    const aiPhrases = [
        /^Sure,.*?:/im,
        /^Here is the.*?text:/im,
        /^Here's the.*?version:/im,
        /^I've formatted.*?below:/im,
        /^I hope this helps.*?$/im,
        /^Let me know if.*?$/im,
        /Generated by ChatGPT/im,
        /^If you want.*?$/im,
        /^I can turn.*?$/im,
        /^Feel free to.*?$/im,
        /^Would you like.*?$/im,
        /^Do you want.*?$/im,
        /^Let me know.*?$/im
    ];
    aiPhrases.forEach(regex => { text = text.replace(regex, ''); });
    text = text.replace(/[\u200B-\u200D\uFEFF]/g, '');

    // Remove leading garbage (single dots, commas, etc. at start of text)
    // Only remove dots/commas/whitespace, NOT markdown chars like * or - or #
    text = text.replace(/^[\s\.\,]+/, '');

    // --- 1. Process Lines (Stateful for Code Blocks) ---
    let lines = text.split('\n');
    let formattedHTML = '';
    let inCodeBlock = false;

    lines.forEach(line => {
        // Check for Code Block Delimiter (```)
        if (line.trim().startsWith('```')) {
            if (inCodeBlock) {
                // End Code Block
                formattedHTML += '</code></pre>\n';
                inCodeBlock = false;
            } else {
                // Start Code Block
                formattedHTML += '<pre contenteditable="false" class="bg-gray-50 text-gray-800 p-4 rounded-lg my-4 overflow-x-auto font-mono text-sm shadow-sm border border-gray-200"><code>';
                inCodeBlock = true;
            }
            return;
        }

        // Inside Code Block: Preserve content exactly
        if (inCodeBlock) {
            formattedHTML += escapeHtml(line) + '\n';
            return;
        }

        // --- Normal Text Processing ---

        // 1. Preserve Indentation but clean internal spaces
        const match = line.match(/^([ \t]*)(.*)$/);
        const indentation = match[1] || '';
        let content = match[2] || '';

        // Skip empty lines
        if (!content) return;

        // Skip "Noise" lines (just a dot, comma, or single char garbage)
        if (/^[\.\,\-\*]$/.test(content.trim())) return;

        // Skip Separator Lines (e.g. "---", "***")
        if (/^[-*_]{3,}\s*$/.test(content)) return;

        // Remove trailing '---' or similar from end of lines
        content = content.replace(/\s+[-*_]{3,}\s*$/, '');

        // Collapse multiple spaces BETWEEN words, but keep leading indentation
        content = content.replace(/[ \t]{2,}/g, ' ');

        // Calculate Indentation Level
        let indentClass = '';
        const spaceCount = indentation.replace(/\t/g, '  ').length; // Treat tab as 2 spaces
        if (spaceCount >= 8) indentClass = 'ml-12';
        else if (spaceCount >= 4) indentClass = 'ml-8';
        else if (spaceCount >= 2) indentClass = 'ml-4';

        // 2. Detect Types

        // Headings (Markdown #)
        if (content.startsWith('#')) {
            const headingContent = content.replace(/^#+\s*/, '');
            formattedHTML += `<h3 class="text-lg font-bold text-gray-900 mt-6 mb-3 ${indentClass}">${applyInlineFormatting(headingContent)}</h3>`;
            return;
        }

        // Bullet Points / List Items (PRIORITIZED)
        if (/^[-*+•]\s/.test(content)) {
            const cleanContent = content.replace(/^[-*+•]\s/, '');

            // Hollow dot for indented subpoints (>= 2 spaces), Solid for main
            const isSubpoint = spaceCount >= 2;
            // Use CSS shapes for cleaner look than characters
            const bullet = isSubpoint
                ? '<span class="flex-none w-1.5 h-1.5 mt-2.5 border border-primary rounded-full"></span>' // Hollow
                : '<span class="flex-none w-1.5 h-1.5 mt-2.5 bg-primary rounded-full"></span>'; // Solid

            formattedHTML += `<div class="flex gap-3 mb-1 ${indentClass}">
                ${bullet}
                <span class="text-gray-700 flex-1">${applyInlineFormatting(cleanContent)}</span>
             </div>`;
            return;
        }

        // Questions (e.g. "1.", "Q1.") - Top level or slight indent
        if (spaceCount < 4 && /^(Q?uestion\s?\d+|Q\d+|\d+)[\.:\)]\s/i.test(content)) {
            formattedHTML += `<h3 class="text-base font-bold text-gray-900 mt-4 mb-2 ${indentClass}">${applyInlineFormatting(content)}</h3>`;
            return;
        }

        // Numbered Sub-points (e.g. "a.", "i.")
        if (/^([a-z]|\d+|[ivx]+)[\.:\)]\s/i.test(content)) {
            formattedHTML += `<div class="mb-1 ${indentClass} text-gray-700 font-medium">
                ${applyInlineFormatting(content)}
             </div>`;
            return;
        }

        // Important Points (Ends with :)
        if (content.length < 80 && content.endsWith(':')) {
            formattedHTML += `<strong class="font-bold text-gray-800 block mt-3 mb-1 ${indentClass}">${applyInlineFormatting(content)}</strong>`;
            return;
        }

        // Regular Paragraph
        formattedHTML += `<p class="mb-2 leading-relaxed text-gray-600 ${indentClass}">${applyInlineFormatting(content)}</p>`;
    });

    const outputField = document.getElementById('output');
    outputField.innerHTML = formattedHTML;

    // Subtle Flash Effect
    outputField.classList.add('bg-indigo-50');
    setTimeout(() => { outputField.classList.remove('bg-indigo-50'); }, 300);
}

function applyInlineFormatting(text) {
    text = text.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-gray-900">$1</strong>');
    text = text.replace(/__(.*?)__/g, '<strong class="font-bold text-gray-900">$1</strong>');
    text = text.replace(/([^\\])\*([^\s*].*?[^\s*])\*/g, '$1<em class="italic text-gray-600">$2</em>');
    // Inline code `code`
    text = text.replace(/`([^`]+)`/g, '<code class="bg-gray-100 text-pink-600 px-1 py-0.5 rounded font-mono text-sm">$1</code>');
    return text;
}

function escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function clearText(id) {
    const el = document.getElementById(id);
    if (el.tagName === 'TEXTAREA') el.value = '';
    else el.innerHTML = '';
}

function copyToClipboard() {
    const output = document.getElementById('output');
    const range = document.createRange();
    range.selectNodeContents(output);
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
    try {
        document.execCommand('copy');
        showToast();
    } catch (err) { console.error('Failed', err); }
    selection.removeAllRanges();
}

function downloadWord() {
    const output = document.getElementById('output');
    const html = output.innerHTML;

    // Create a simple HTML document for Word with default settings
    const wordHTML = `
        <html xmlns:o='urn:schemas-microsoft-com:office:office' 
              xmlns:w='urn:schemas-microsoft-com:office:word' 
              xmlns='http://www.w3.org/TR/REC-html40'>
        <head>
            <meta charset='utf-8'>
            <title>Formatted Document</title>
        </head>
        <body>${html}</body>
        </html>
    `;

    // Create blob and download
    const blob = new Blob(['\ufeff', wordHTML], {
        type: 'application/msword'
    });

    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'formatted-document.doc';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

function downloadPDF() {
    const output = document.getElementById('output');
    
    if (!output.innerHTML.trim()) {
        alert('Please format some text first!');
        return;
    }

    // Detect if mobile device
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (isMobile) {
        // Show instructions for mobile
        const proceed = confirm(
            'To save as PDF on mobile:\n\n' +
            '1. In the print dialog, tap "More options" or the three dots\n' +
            '2. Look for "Save as PDF" or "Print to PDF"\n' +
            '3. Tap it and then tap the Print/Save button\n\n' +
            'Click OK to open print dialog.'
        );
        
        if (proceed) {
            window.print();
        }
    } else {
        // Desktop: direct print
        window.print();
    }
}

function showToast() {
    const toast = document.getElementById('toast');
    toast.classList.remove('translate-y-20', 'opacity-0');
    setTimeout(() => {
        toast.classList.add('translate-y-20', 'opacity-0');
    }, 2000);
}

function toggleExportMenu() {
    const menu = document.getElementById('exportMenu');
    menu.classList.toggle('hidden');
}

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
    const menu = document.getElementById('exportMenu');
    const btn = document.getElementById('exportMenuBtn');
    if (menu && btn && !menu.contains(event.target) && !btn.contains(event.target)) {
        menu.classList.add('hidden');
    }
});

// Suppress browser extension storage errors
window.addEventListener('error', function(e) {
    if (e.message && e.message.includes('storage')) {
        e.preventDefault();
        return true;
    }
});

window.addEventListener('unhandledrejection', function(e) {
    if (e.reason && e.reason.message && e.reason.message.includes('storage')) {
        e.preventDefault();
        return true;
    }
});
