function processText() {
    const inputField = document.getElementById('input');
    let text = inputField.value;

    if (!text) return;

    // --- 0. Remove AI Watermarks & Artifacts ---
    const aiPhrases = [
        /^Sure,.*?:/im,
        /^Here is the.*?text:/im,
        /^Here's the.*?version:/im,
        /^I've formatted.*?below:/im,
        /^I hope this helps.*?$/im,
        /^Let me know if.*?$/im,
        /Generated by ChatGPT/im,
        /^If you want.*?$/im,
        /^I can turn.*?$/im,
        /^Feel free to.*?$/im,
        /^Would you like.*?$/im,
        /^Do you want.*?$/im,
        /^Let me know.*?$/im
    ];
    aiPhrases.forEach(regex => { text = text.replace(regex, ''); });

    // Remove Emojis (Surrogate pairs and common ranges)
    text = text.replace(/([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|\uD83E[\uDC00-\uDFFF])/g, '');

    text = text.replace(/[\u200B-\u200D\uFEFF]/g, '');

    // Remove leading garbage (single dots, commas, etc. at start of text)
    // Only remove dots/commas/whitespace, NOT markdown chars like * or - or #
    text = text.replace(/^[\s\.\,]+/, '');

    // Replace corrupted angle brackets with parentheses for compatibility
    text = text.replace(/􀀀/g, '(');  // Opening bracket
    text = text.replace(/\uDB40\uDC00/g, '(');  // Surrogate pair
    text = text.replace(/\uFFFD/g, '(');  // Replacement char
    text = text.replace(/⟨/g, '(');  // Mathematical left angle bracket
    text = text.replace(/⟩/g, ')');  // Mathematical right angle bracket

    // Fix spacing corruption from the garbage characters
    text = text.replace(/array\[0\]\)a,\s*rray\[1\]/g, 'array[0], array[1]');
    text = text.replace(/\)([a-z]),\s*([a-z])rray/g, ')$1, $2rray');

    // --- 1. Process Lines (Stateful for Code Blocks and Tables) ---
    let lines = text.split('\n');
    let formattedHTML = '';
    let inCodeBlock = false;
    let inTable = false;
    let tableLines = [];

    lines.forEach((line, index) => {
        // Check for Code Block Delimiter (```)
        if (line.trim().startsWith('```')) {
            // If we're in a table, end it first
            if (inTable && tableLines.length > 0) {
                formattedHTML += buildTableHTML(tableLines);
                inTable = false;
                tableLines = [];
            }

            if (inCodeBlock) {
                formattedHTML += '</code></pre>\n';
                inCodeBlock = false;
            } else {
                formattedHTML += '<pre contenteditable="false" class="bg-gray-50 text-gray-800 p-4 rounded-lg my-4 overflow-x-auto font-mono text-sm shadow-sm border border-gray-200"><code>';
                inCodeBlock = true;
            }
            return;
        }

        // Inside Code Block: Preserve content exactly (no escaping)
        if (inCodeBlock) {
            formattedHTML += line + '\n';
            return;
        }

        // Check if this line is part of a table (has at least 2 | characters)
        const trimmed = line.trim();
        const pipeCount = (line.match(/\|/g) || []).length;

        if (pipeCount >= 2 && trimmed.length > 0) {
            // Check if it's a separator line
            if (/^\s*\|[\s\-:|]+\|\s*$/.test(line)) {
                inTable = true;
                return; // Skip separator
            }

            // This is a table data line
            if (!inTable) {
                inTable = true;
                tableLines = [];
            }
            tableLines.push(line);

            // Check if next line is also a table line
            const nextLine = lines[index + 1];
            const nextPipes = nextLine ? (nextLine.match(/\|/g) || []).length : 0;

            // If next line is not a table, render the table now
            if (nextPipes < 2) {
                formattedHTML += buildTableHTML(tableLines);
                inTable = false;
                tableLines = [];
            }
            return;
        }

        // Not a table line - if we were building a table, finish it
        if (inTable && tableLines.length > 0) {
            formattedHTML += buildTableHTML(tableLines);
            inTable = false;
            tableLines = [];
        }

        // --- Normal Text Processing ---

        // 1. Preserve Indentation but clean internal spaces
        const match = line.match(/^([ \t]*)(.*)$/);
        const indentation = match[1] || '';
        let content = match[2] || '';

        // Skip empty lines
        if (!content) return;

        // Skip "Noise" lines (just a dot, comma, or single char garbage)
        if (/^[\.\,\-\*]$/.test(content.trim())) return;

        // Skip Separator Lines (e.g. "---", "***")
        if (/^[-*_]{3,}\s*$/.test(content)) return;

        // Remove trailing '---' or similar from end of lines
        content = content.replace(/\s+[-*_]{3,}\s*$/, '');

        // Collapse multiple spaces BETWEEN words, but keep leading indentation
        content = content.replace(/[ \t]{2,}/g, ' ');

        // Calculate Indentation Level
        let indentClass = '';
        const spaceCount = indentation.replace(/\t/g, '  ').length; // Treat tab as 2 spaces
        if (spaceCount >= 8) indentClass = 'ml-12';
        else if (spaceCount >= 4) indentClass = 'ml-8';
        else if (spaceCount >= 2) indentClass = 'ml-4';

        // 2. Detect Types

        // Headings (Markdown #)
        if (content.startsWith('#')) {
            const headingContent = content.replace(/^#+\s*/, '');
            formattedHTML += `<h3 class="text-base font-bold leading-tight text-gray-900 mt-6 mb-3 ${indentClass}">${applyInlineFormatting(headingContent)}</h3>`;
            return;
        }

        // Bullet Points / List Items (PRIORITIZED)
        if (/^[-*+•]\s/.test(content)) {
            const cleanContent = content.replace(/^[-*+•]\s/, '');

            // Hollow dot for indented subpoints (>= 2 spaces), Solid for main
            const isSubpoint = spaceCount >= 2;
            // Use CSS shapes for cleaner look than characters
            const bullet = isSubpoint
                ? '<span class="flex-none w-1.5 h-1.5 mt-2.5 border border-primary rounded-full"></span>' // Hollow
                : '<span class="flex-none w-1.5 h-1.5 mt-2.5 bg-primary rounded-full"></span>'; // Solid

            formattedHTML += `<div class="flex gap-3 mb-1 ${indentClass}">${bullet}<span class="text-gray-700 flex-1">${applyInlineFormatting(cleanContent)}</span></div>`;
            return;
        }

        // Questions (e.g. "1.", "Q1.") - Top level or slight indent
        if (spaceCount < 4 && /^(Q?uestion\s?\d+|Q\d+|\d+)[\.:\)]\s/i.test(content)) {
            formattedHTML += `<h3 class="text-base font-bold text-gray-900 mt-4 mb-2 ${indentClass}">${applyInlineFormatting(content)}</h3>`;
            return;
        }

        // Numbered Sub-points (e.g. "a.", "i.")
        if (/^([a-z]|\d+|[ivx]+)[\.:\)]\s/i.test(content)) {
            formattedHTML += `<div class="mb-1 ${indentClass} text-gray-700 font-medium">
                ${applyInlineFormatting(content)}
             </div>`;
            return;
        }

        // Code-like lines (contains array notation, brackets, special chars)
        if (/[⟨⟩<>\[\]{}]|array\[|\.\.\./.test(content)) {
            // Don't escape HTML entities - preserve special characters as-is
            const preservedContent = content.replace(/&/g, "&amp;").replace(/"/g, "&quot;");
            formattedHTML += `<pre class="bg-gray-50 text-gray-800 px-3 py-2 rounded my-2 font-mono text-sm ${indentClass}">${preservedContent}</pre>`;
            return;
        }

        // Important Points (Ends with :)
        if (content.length < 80 && content.endsWith(':')) {
            formattedHTML += `<strong class="font-bold text-gray-800 block mt-3 mb-1 ${indentClass}">${applyInlineFormatting(content)}</strong>`;
            return;
        }

        // Regular Paragraph
        formattedHTML += `<p class="mb-2 leading-relaxed text-gray-600 ${indentClass}">${applyInlineFormatting(content)}</p>`;
    });

    // If we ended while in a table, render it
    if (inTable && tableLines.length > 0) {
        formattedHTML += buildTableHTML(tableLines);
    }

    const outputField = document.getElementById('output');
    outputField.innerHTML = formattedHTML;

    // Subtle Flash Effect
    outputField.classList.add('bg-indigo-50');
    setTimeout(() => { outputField.classList.remove('bg-indigo-50'); }, 300);
}

function applyInlineFormatting(text) {
    // First, collapse all newlines and multiple spaces into single spaces
    text = text.replace(/\s+/g, ' ').trim();

    text = text.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-gray-900">$1</strong>');
    text = text.replace(/__(.*?)__/g, '<strong class="font-bold text-gray-900">$1</strong>');
    text = text.replace(/([^\\])\*([^\s*].*?[^\s*])\*/g, '$1<em class="italic text-gray-600">$2</em>');
    // Inline code `code`
    text = text.replace(/`([^`]+)`/g, '<code class="bg-gray-100 text-pink-600 px-1 py-0.5 rounded font-mono text-sm">$1</code>');
    return text;
}

function escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function buildTableHTML(rows) {
    if (rows.length === 0) return '';

    let html = '<div class="overflow-x-auto my-4"><table class="min-w-full border-collapse border border-gray-300">';

    rows.forEach((row, index) => {
        // Split by | 
        let cells = row.split('|');
        // Remove first and last if empty
        if (cells[0].trim() === '') cells.shift();
        if (cells[cells.length - 1].trim() === '') cells.pop();

        html += '<tr>';
        cells.forEach(cell => {
            const cellContent = cell.trim();
            if (index === 0) {
                html += `<th class="border border-gray-300 bg-gray-100 px-4 py-2 text-left font-semibold text-gray-900">${cellContent}</th>`;
            } else {
                html += `<td class="border border-gray-300 px-4 py-2 text-gray-700">${cellContent}</td>`;
            }
        });
        html += '</tr>';
    });

    html += '</table></div>';
    return html;
}

function clearText(id) {
    const el = document.getElementById(id);
    if (el.tagName === 'TEXTAREA') el.value = '';
    else el.innerHTML = '';
}

function copyToClipboard() {
    const output = document.getElementById('output');
    const range = document.createRange();
    range.selectNodeContents(output);
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
    try {
        document.execCommand('copy');
        showToast();
    } catch (err) { console.error('Failed', err); }
    selection.removeAllRanges();
}

function downloadWord() {
    const output = document.getElementById('output');
    const html = output.innerHTML;

    // Create a simple HTML document for Word with default settings
    const wordHTML = `
        <html xmlns:o='urn:schemas-microsoft-com:office:office' 
              xmlns:w='urn:schemas-microsoft-com:office:word' 
              xmlns='http://www.w3.org/TR/REC-html40'>
        <head>
            <meta charset='utf-8'>
            <title>Formatted Document</title>
        </head>
        <body>${html}</body>
        </html>
    `;

    // Create blob and download
    const blob = new Blob(['\ufeff', wordHTML], {
        type: 'application/msword'
    });

    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'formatted-document.doc';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    Swal.fire({
        icon: 'success',
        title: 'Word Downloaded',
        text: 'Your formatted document is ready!',
        timer: 2000,
        showConfirmButton: false,
        customClass: {
            popup: 'rounded-lg',
            title: 'text-gray-800 font-semibold',
            htmlContainer: 'text-gray-600'
        }
    });
}

function downloadPDF() {
    const output = document.getElementById('output');

    if (!output.innerHTML.trim()) {
        Swal.fire({
            icon: 'warning',
            title: 'No Content',
            text: 'Please format some text first!',
            confirmButtonText: 'OK',
            confirmButtonColor: '#6366f1',
            customClass: {
                popup: 'rounded-lg',
                title: 'text-gray-800 font-semibold',
                htmlContainer: 'text-gray-600',
                confirmButton: 'rounded-lg px-6 py-2'
            }
        });
        return;
    }

    try {
        const content = [];
        const children = Array.from(output.children);

        children.forEach(child => {
            const parsed = parseElement(child);
            if (parsed) {
                content.push(parsed);
            }
        });

        const docDefinition = {
            content: content.length > 0 ? content : [{ text: 'No content to display', style: 'paragraph' }],
            pageSize: 'A4',
            pageMargins: [28, 28, 28, 50],
            defaultStyle: {
                fontSize: 12,
                lineHeight: 1.15
            },
            styles: {
                header: {
                    fontSize: 12,
                    bold: true,
                    lineHeight: 1.1,
                    margin: [0, 5, 0, 3],
                    color: '#111827'
                },
                codeBlock: {
                    fontSize: 10,
                    background: '#f9fafb',
                    margin: [0, 10, 0, 10],
                    fillColor: '#f9fafb'
                },
                bullet: {
                    margin: [0, 2, 0, 2]
                },
                paragraph: {
                    margin: [0, 2, 0, 2]
                },
                tableHeader: {
                    bold: true,
                    fontSize: 11,
                    color: '#111827',
                    fillColor: '#f3f4f6'
                },
                tableCell: {
                    fontSize: 11,
                    color: '#374151'
                }
            },
            footer: function (currentPage, pageCount) {
                return {
                    text: currentPage.toString() + ' of ' + pageCount,
                    alignment: 'center',
                    fontSize: 10,
                    margin: [0, 10, 0, 0]
                };
            }
        };

        pdfMake.createPdf(docDefinition).download('formatted-document.pdf');

        Swal.fire({
            icon: 'success',
            title: 'PDF Downloaded',
            text: 'Your formatted document is ready!',
            timer: 2000,
            showConfirmButton: false,
            customClass: {
                popup: 'rounded-lg',
                title: 'text-gray-800 font-semibold',
                htmlContainer: 'text-gray-600'
            }
        });

    } catch (error) {
        console.error('PDF failed:', error);
        Swal.fire({
            icon: 'error',
            title: 'Download Failed',
            text: 'PDF generation failed. Please try Word format instead.',
            confirmButtonText: 'OK',
            confirmButtonColor: '#6366f1',
            customClass: {
                popup: 'rounded-lg',
                title: 'text-gray-800 font-semibold',
                htmlContainer: 'text-gray-600',
                confirmButton: 'rounded-lg px-6 py-2'
            }
        });
    }
}

function parseElement(element) {
    if (!element || !element.tagName) return null;

    const tag = element.tagName.toLowerCase();
    const text = element.textContent || '';

    // Check if this div contains a table
    if (tag === 'div' && element.classList.contains('overflow-x-auto')) {
        const table = element.querySelector('table');
        if (table) {
            return parseTable(table);
        }
    }

    // Tables (direct)
    if (tag === 'table') {
        return parseTable(element);
    }

    // Headings (includes questions with numbers like "1(i)", "2.", etc.)
    if (tag === 'h3' || tag === 'h2' || tag === 'h1') {
        return {
            text: getTextWithFormatting(element),
            style: 'header',
            margin: [0, 5, 0, 3]
        };
    }

    // Code blocks
    if (tag === 'pre') {
        const codeEl = element.querySelector('code');
        const codeText = codeEl ? codeEl.textContent : element.textContent;
        return {
            text: codeText,
            style: 'codeBlock',
            preserveLeadingSpaces: true
        };
    }

    // Bullet points (div with flex class)
    if (tag === 'div' && element.classList.contains('flex')) {
        // Find the text span - it could be .flex-1, .text-gray-700, or just a span
        const textSpan = element.querySelector('span.flex-1, span.text-gray-700, span:last-child');

        if (textSpan && textSpan.textContent.trim()) {
            const isSubpoint = element.classList.contains('ml-4') ||
                element.classList.contains('ml-8') ||
                element.classList.contains('ml-12');

            // Get the text and force it to be on one line
            const rawText = textSpan.innerHTML;
            // Remove all HTML tags and decode entities, then collapse whitespace
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = rawText;
            let plainText = tempDiv.textContent || tempDiv.innerText || '';
            // Replace all newlines and multiple spaces with single space
            plainText = plainText.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();

            // Now apply formatting to the cleaned text
            const bulletText = parseFormattedText(textSpan, plainText);

            // Use pdfmake's built-in list format
            return {
                ul: [bulletText],
                margin: isSubpoint ? [20, 2, 0, 2] : [0, 2, 0, 2],
                type: isSubpoint ? 'circle' : 'disc'
            };
        }

        // If no text found, return null to skip this element
        return null;
    }

    // Strong/bold blocks (for section headings that end with colon)
    if (tag === 'strong') {
        return {
            text: getTextWithFormatting(element),
            bold: true,
            margin: [0, 8, 0, 3]
        };
    }

    // Regular paragraphs
    if (tag === 'p') {
        if (!text.trim()) return null;

        const textContent = getTextWithFormatting(element);
        if (textContent) {
            return {
                text: textContent,
                style: 'paragraph'
            };
        }
    }

    // Generic divs that contain text (but not flex items)
    if (tag === 'div' && !element.classList.contains('flex') && text.trim()) {
        const textContent = getTextWithFormatting(element);
        if (textContent) {
            // Check if it's a numbered item like "1.", "a.", "i."
            const firstText = typeof textContent === 'string' ? textContent :
                Array.isArray(textContent) ? textContent[0] : '';

            if (typeof firstText === 'string' && /^([a-z]|\d+|[ivx]+)[\.:\)]\s/i.test(firstText)) {
                return {
                    text: textContent,
                    margin: [0, 3, 0, 3],
                    bold: true
                };
            }

            return {
                text: textContent,
                style: 'paragraph'
            };
        }
    }

    return null;
}

function getTextWithFormatting(element) {
    if (!element) return '';

    const result = [];

    function processNode(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            // Replace multiple spaces/newlines with single space for inline text
            return text.replace(/\s+/g, ' ');
        }

        if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();

            // Skip bullet spans (visual only)
            if (tag === 'span' && (node.classList.contains('w-1.5') || node.classList.contains('flex-none'))) {
                return '';
            }

            const children = Array.from(node.childNodes).map(processNode);
            const text = children.join('');

            if (!text.trim()) return '';

            // Bold - increase font size slightly for bolder appearance
            if (tag === 'strong' || tag === 'b') {
                return { text: text, bold: true, fontSize: 13 };
            }

            // Italic
            if (tag === 'em' || tag === 'i') {
                return { text: text, italics: true };
            }

            // Code (inline)
            if (tag === 'code') {
                return { text: text, background: '#f3f4f6' };
            }

            // Line break - use space instead for inline content
            if (tag === 'br') {
                return ' ';
            }

            // Span elements - just return their text
            if (tag === 'span') {
                return text;
            }

            return text;
        }

        return '';
    }

    Array.from(element.childNodes).forEach(node => {
        const processed = processNode(node);
        if (processed !== '') {
            result.push(processed);
        }
    });

    // Flatten and clean up result
    if (result.length === 0) return '';

    let finalText;
    if (result.length === 1) {
        finalText = result[0];
    } else {
        finalText = result;
    }

    // If it's a string, clean up extra spaces
    if (typeof finalText === 'string') {
        finalText = finalText.replace(/\s+/g, ' ').trim();
    }

    return finalText;
}

function parseFormattedText(element, plainText) {
    // Just return the plain text for now - simple and reliable
    return plainText;
}

function parseTable(tableElement) {
    const rows = Array.from(tableElement.querySelectorAll('tr'));
    if (rows.length === 0) return null;

    const tableBody = [];

    rows.forEach((row, rowIndex) => {
        const cells = Array.from(row.querySelectorAll('th, td'));
        const rowData = cells.map(cell => {
            // Get raw text content, preserving special characters
            let text = cell.textContent || cell.innerText || '';
            // Only collapse multiple spaces, don't strip special characters
            text = text.replace(/ {2,}/g, ' ').trim();

            return {
                text: text,
                bold: rowIndex === 0,
                fontSize: 10,
                margin: [3, 3, 3, 3],
                preserveLeadingSpaces: false
            };
        });

        tableBody.push(rowData);
    });

    // Use auto widths for better fitting
    const colCount = tableBody[0] ? tableBody[0].length : 0;
    const widths = Array(colCount).fill('*');

    return {
        table: {
            headerRows: 1,
            widths: widths,
            body: tableBody,
            dontBreakRows: true
        },
        layout: {
            fillColor: function (rowIndex) {
                return rowIndex === 0 ? '#f3f4f6' : null;
            },
            hLineWidth: function () { return 0.5; },
            vLineWidth: function () { return 0.5; },
            hLineColor: function () { return '#d1d5db'; },
            vLineColor: function () { return '#d1d5db'; },
            paddingLeft: function () { return 5; },
            paddingRight: function () { return 5; },
            paddingTop: function () { return 4; },
            paddingBottom: function () { return 4; }
        },
        margin: [0, 8, 0, 8]
    };
}

function showToast() {
    const toast = document.getElementById('toast');
    toast.classList.remove('translate-y-20', 'opacity-0');
    setTimeout(() => {
        toast.classList.add('translate-y-20', 'opacity-0');
    }, 2000);
}

function toggleExportMenu() {
    const menu = document.getElementById('exportMenu');
    menu.classList.toggle('hidden');
}

// Close dropdown when clicking outside
document.addEventListener('click', function (event) {
    const menu = document.getElementById('exportMenu');
    const btn = document.getElementById('exportMenuBtn');
    if (menu && btn && !menu.contains(event.target) && !btn.contains(event.target)) {
        menu.classList.add('hidden');
    }
});

// Suppress browser extension storage errors
window.addEventListener('error', function (e) {
    if (e.message && e.message.includes('storage')) {
        e.preventDefault();
        return true;
    }
});

window.addEventListener('unhandledrejection', function (e) {
    if (e.reason && e.reason.message && e.reason.message.includes('storage')) {
        e.preventDefault();
        return true;
    }
});
