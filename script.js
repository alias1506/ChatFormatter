function processText() {
    const inputField = document.getElementById('input');
    let text = inputField.value;

    if (!text) return;

    // --- 0. Remove AI Watermarks & Artifacts ---
    const aiPhrases = [
        /^Sure,.*?:/im,
        /^Here is the.*?text:/im,
        /^Here's the.*?version:/im,
        /^I've formatted.*?below:/im,
        /^I hope this helps.*?$/im,
        /^Let me know if.*?$/im,
        /Generated by ChatGPT/im,
        /^If you want.*?$/im,
        /^I can turn.*?$/im,
        /^Feel free to.*?$/im,
        /^Would you like.*?$/im,
        /^Do you want.*?$/im,
        /^Let me know.*?$/im
    ];
    aiPhrases.forEach(regex => { text = text.replace(regex, ''); });
    text = text.replace(/[\u200B-\u200D\uFEFF]/g, '');

    // Remove leading garbage (single dots, commas, etc. at start of text)
    // Only remove dots/commas/whitespace, NOT markdown chars like * or - or #
    text = text.replace(/^[\s\.\,]+/, '');

    // --- 1. Process Lines (Stateful for Code Blocks) ---
    let lines = text.split('\n');
    let formattedHTML = '';
    let inCodeBlock = false;

    lines.forEach(line => {
        // Check for Code Block Delimiter (```)
        if (line.trim().startsWith('```')) {
            if (inCodeBlock) {
                // End Code Block
                formattedHTML += '</code></pre>\n';
                inCodeBlock = false;
            } else {
                // Start Code Block
                formattedHTML += '<pre contenteditable="false" class="bg-gray-50 text-gray-800 p-4 rounded-lg my-4 overflow-x-auto font-mono text-sm shadow-sm border border-gray-200"><code>';
                inCodeBlock = true;
            }
            return;
        }

        // Inside Code Block: Preserve content exactly
        if (inCodeBlock) {
            formattedHTML += escapeHtml(line) + '\n';
            return;
        }

        // --- Normal Text Processing ---

        // 1. Preserve Indentation but clean internal spaces
        const match = line.match(/^([ \t]*)(.*)$/);
        const indentation = match[1] || '';
        let content = match[2] || '';

        // Skip empty lines
        if (!content) return;

        // Skip "Noise" lines (just a dot, comma, or single char garbage)
        if (/^[\.\,\-\*]$/.test(content.trim())) return;

        // Skip Separator Lines (e.g. "---", "***")
        if (/^[-*_]{3,}\s*$/.test(content)) return;

        // Remove trailing '---' or similar from end of lines
        content = content.replace(/\s+[-*_]{3,}\s*$/, '');

        // Collapse multiple spaces BETWEEN words, but keep leading indentation
        content = content.replace(/[ \t]{2,}/g, ' ');

        // Calculate Indentation Level
        let indentClass = '';
        const spaceCount = indentation.replace(/\t/g, '  ').length; // Treat tab as 2 spaces
        if (spaceCount >= 8) indentClass = 'ml-12';
        else if (spaceCount >= 4) indentClass = 'ml-8';
        else if (spaceCount >= 2) indentClass = 'ml-4';

        // 2. Detect Types

        // Headings (Markdown #)
        if (content.startsWith('#')) {
            const headingContent = content.replace(/^#+\s*/, '');
            formattedHTML += `<h3 class="text-lg font-bold text-gray-900 mt-6 mb-3 ${indentClass}">${applyInlineFormatting(headingContent)}</h3>`;
            return;
        }

        // Bullet Points / List Items (PRIORITIZED)
        if (/^[-*+•]\s/.test(content)) {
            const cleanContent = content.replace(/^[-*+•]\s/, '');

            // Hollow dot for indented subpoints (>= 2 spaces), Solid for main
            const isSubpoint = spaceCount >= 2;
            // Use CSS shapes for cleaner look than characters
            const bullet = isSubpoint
                ? '<span class="flex-none w-1.5 h-1.5 mt-2.5 border border-primary rounded-full"></span>' // Hollow
                : '<span class="flex-none w-1.5 h-1.5 mt-2.5 bg-primary rounded-full"></span>'; // Solid

            formattedHTML += `<div class="flex gap-3 mb-1 ${indentClass}">${bullet}<span class="text-gray-700 flex-1">${applyInlineFormatting(cleanContent)}</span></div>`;
            return;
        }

        // Questions (e.g. "1.", "Q1.") - Top level or slight indent
        if (spaceCount < 4 && /^(Q?uestion\s?\d+|Q\d+|\d+)[\.:\)]\s/i.test(content)) {
            formattedHTML += `<h3 class="text-base font-bold text-gray-900 mt-4 mb-2 ${indentClass}">${applyInlineFormatting(content)}</h3>`;
            return;
        }

        // Numbered Sub-points (e.g. "a.", "i.")
        if (/^([a-z]|\d+|[ivx]+)[\.:\)]\s/i.test(content)) {
            formattedHTML += `<div class="mb-1 ${indentClass} text-gray-700 font-medium">
                ${applyInlineFormatting(content)}
             </div>`;
            return;
        }

        // Important Points (Ends with :)
        if (content.length < 80 && content.endsWith(':')) {
            formattedHTML += `<strong class="font-bold text-gray-800 block mt-3 mb-1 ${indentClass}">${applyInlineFormatting(content)}</strong>`;
            return;
        }

        // Regular Paragraph
        formattedHTML += `<p class="mb-2 leading-relaxed text-gray-600 ${indentClass}">${applyInlineFormatting(content)}</p>`;
    });

    const outputField = document.getElementById('output');
    outputField.innerHTML = formattedHTML;

    // Subtle Flash Effect
    outputField.classList.add('bg-indigo-50');
    setTimeout(() => { outputField.classList.remove('bg-indigo-50'); }, 300);
}

function applyInlineFormatting(text) {
    // First, collapse all newlines and multiple spaces into single spaces
    text = text.replace(/\s+/g, ' ').trim();
    
    text = text.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-gray-900">$1</strong>');
    text = text.replace(/__(.*?)__/g, '<strong class="font-bold text-gray-900">$1</strong>');
    text = text.replace(/([^\\])\*([^\s*].*?[^\s*])\*/g, '$1<em class="italic text-gray-600">$2</em>');
    // Inline code `code`
    text = text.replace(/`([^`]+)`/g, '<code class="bg-gray-100 text-pink-600 px-1 py-0.5 rounded font-mono text-sm">$1</code>');
    return text;
}

function escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function clearText(id) {
    const el = document.getElementById(id);
    if (el.tagName === 'TEXTAREA') el.value = '';
    else el.innerHTML = '';
}

function copyToClipboard() {
    const output = document.getElementById('output');
    const range = document.createRange();
    range.selectNodeContents(output);
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
    try {
        document.execCommand('copy');
        showToast();
    } catch (err) { console.error('Failed', err); }
    selection.removeAllRanges();
}

function downloadWord() {
    const output = document.getElementById('output');
    const html = output.innerHTML;

    // Create a simple HTML document for Word with default settings
    const wordHTML = `
        <html xmlns:o='urn:schemas-microsoft-com:office:office' 
              xmlns:w='urn:schemas-microsoft-com:office:word' 
              xmlns='http://www.w3.org/TR/REC-html40'>
        <head>
            <meta charset='utf-8'>
            <title>Formatted Document</title>
        </head>
        <body>${html}</body>
        </html>
    `;

    // Create blob and download
    const blob = new Blob(['\ufeff', wordHTML], {
        type: 'application/msword'
    });

    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'formatted-document.doc';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    Swal.fire({
        icon: 'success',
        title: 'Word Downloaded',
        text: 'Your formatted document is ready!',
        timer: 2000,
        showConfirmButton: false,
        customClass: {
            popup: 'rounded-lg',
            title: 'text-gray-800 font-semibold',
            htmlContainer: 'text-gray-600'
        }
    });
}

function downloadPDF() {
    const output = document.getElementById('output');
    
    if (!output.innerHTML.trim()) {
        alert('Please format some text first!');
        return;
    }

    try {
        const content = [];
        const children = Array.from(output.children);
        
        children.forEach(child => {
            const parsed = parseElement(child);
            if (parsed) {
                content.push(parsed);
            }
        });
        
        const docDefinition = {
            content: content.length > 0 ? content : [{ text: 'No content to display', style: 'paragraph' }],
            pageSize: 'A4',
            pageMargins: [28, 28, 28, 50],
            defaultStyle: {
                fontSize: 12,
                lineHeight: 1.4
            },
            styles: {
                header: {
                    fontSize: 16,
                    bold: true,
                    margin: [0, 15, 0, 10],
                    color: '#111827'
                },
                codeBlock: {
                    fontSize: 10,
                    background: '#f9fafb',
                    margin: [0, 10, 0, 10],
                    fillColor: '#f9fafb'
                },
                bullet: {
                    margin: [0, 3, 0, 3]
                },
                paragraph: {
                    margin: [0, 5, 0, 5]
                }
            },
            footer: function(currentPage, pageCount) {
                return {
                    text: currentPage.toString() + ' of ' + pageCount,
                    alignment: 'center',
                    fontSize: 10,
                    margin: [0, 10, 0, 0]
                };
            }
        };

        pdfMake.createPdf(docDefinition).download('formatted-document.pdf');
        
        Swal.fire({
            icon: 'success',
            title: 'PDF Downloaded',
            text: 'Your formatted document is ready!',
            timer: 2000,
            showConfirmButton: false,
            customClass: {
                popup: 'rounded-lg',
                title: 'text-gray-800 font-semibold',
                htmlContainer: 'text-gray-600'
            }
        });
        
    } catch (error) {
        console.error('PDF failed:', error);
        Swal.fire({
            icon: 'error',
            title: 'Download Failed',
            text: 'PDF generation failed. Please try Word format instead.',
            confirmButtonText: 'OK',
            confirmButtonColor: '#6366f1',
            customClass: {
                popup: 'rounded-lg',
                title: 'text-gray-800 font-semibold',
                htmlContainer: 'text-gray-600',
                confirmButton: 'rounded-lg px-6 py-2'
            }
        });
    }
}

function parseElement(element) {
    if (!element || !element.tagName) return null;
    
    const tag = element.tagName.toLowerCase();
    const text = element.textContent || '';
    
    // Headings (includes questions with numbers like "1(i)", "2.", etc.)
    if (tag === 'h3' || tag === 'h2' || tag === 'h1') {
        return {
            text: getTextWithFormatting(element),
            style: 'header',
            margin: [0, 12, 0, 8]
        };
    }
    
    // Code blocks
    if (tag === 'pre') {
        const codeEl = element.querySelector('code');
        const codeText = codeEl ? codeEl.textContent : element.textContent;
        return {
            text: codeText,
            style: 'codeBlock',
            preserveLeadingSpaces: true
        };
    }
    
    // Bullet points (div with flex class)
    if (tag === 'div' && element.classList.contains('flex')) {
        // Find the text span - it could be .flex-1, .text-gray-700, or just a span
        const textSpan = element.querySelector('span.flex-1, span.text-gray-700, span:last-child');
        
        if (textSpan && textSpan.textContent.trim()) {
            const isSubpoint = element.classList.contains('ml-4') || 
                             element.classList.contains('ml-8') || 
                             element.classList.contains('ml-12');
            
            // Get the text and force it to be on one line
            const rawText = textSpan.innerHTML;
            // Remove all HTML tags and decode entities, then collapse whitespace
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = rawText;
            let plainText = tempDiv.textContent || tempDiv.innerText || '';
            // Replace all newlines and multiple spaces with single space
            plainText = plainText.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();
            
            // Now apply formatting to the cleaned text
            const bulletText = parseFormattedText(textSpan, plainText);
            
            // Use pdfmake's built-in list format
            return {
                ul: [bulletText],
                margin: isSubpoint ? [20, 2, 0, 2] : [0, 2, 0, 2],
                type: isSubpoint ? 'circle' : 'disc'
            };
        }
        
        // If no text found, return null to skip this element
        return null;
    }
    
    // Strong/bold blocks (for section headings that end with colon)
    if (tag === 'strong') {
        return {
            text: getTextWithFormatting(element),
            bold: true,
            margin: [0, 8, 0, 3]
        };
    }
    
    // Regular paragraphs
    if (tag === 'p') {
        if (!text.trim()) return null;
        
        const textContent = getTextWithFormatting(element);
        if (textContent) {
            return {
                text: textContent,
                style: 'paragraph'
            };
        }
    }
    
    // Generic divs that contain text (but not flex items)
    if (tag === 'div' && !element.classList.contains('flex') && text.trim()) {
        const textContent = getTextWithFormatting(element);
        if (textContent) {
            // Check if it's a numbered item like "1.", "a.", "i."
            const firstText = typeof textContent === 'string' ? textContent : 
                            Array.isArray(textContent) ? textContent[0] : '';
            
            if (typeof firstText === 'string' && /^([a-z]|\d+|[ivx]+)[\.:\)]\s/i.test(firstText)) {
                return {
                    text: textContent,
                    margin: [0, 3, 0, 3],
                    bold: true
                };
            }
            
            return {
                text: textContent,
                style: 'paragraph'
            };
        }
    }
    
    return null;
}

function getTextWithFormatting(element) {
    if (!element) return '';
    
    const result = [];
    
    function processNode(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            // Replace multiple spaces/newlines with single space for inline text
            return text.replace(/\s+/g, ' ');
        }
        
        if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            
            // Skip bullet spans (visual only)
            if (tag === 'span' && (node.classList.contains('w-1.5') || node.classList.contains('flex-none'))) {
                return '';
            }
            
            const children = Array.from(node.childNodes).map(processNode);
            const text = children.join('');
            
            if (!text.trim()) return '';
            
            // Bold - increase font size slightly for bolder appearance
            if (tag === 'strong' || tag === 'b') {
                return { text: text, bold: true, fontSize: 13 };
            }
            
            // Italic
            if (tag === 'em' || tag === 'i') {
                return { text: text, italics: true };
            }
            
            // Code (inline)
            if (tag === 'code') {
                return { text: text, background: '#f3f4f6' };
            }
            
            // Line break - use space instead for inline content
            if (tag === 'br') {
                return ' ';
            }
            
            // Span elements - just return their text
            if (tag === 'span') {
                return text;
            }
            
            return text;
        }
        
        return '';
    }
    
    Array.from(element.childNodes).forEach(node => {
        const processed = processNode(node);
        if (processed !== '') {
            result.push(processed);
        }
    });
    
    // Flatten and clean up result
    if (result.length === 0) return '';
    
    let finalText;
    if (result.length === 1) {
        finalText = result[0];
    } else {
        finalText = result;
    }
    
    // If it's a string, clean up extra spaces
    if (typeof finalText === 'string') {
        finalText = finalText.replace(/\s+/g, ' ').trim();
    }
    
    return finalText;
}

function parseFormattedText(element, plainText) {
    // Just return the plain text for now - simple and reliable
    return plainText;
}

function showToast() {
    const toast = document.getElementById('toast');
    toast.classList.remove('translate-y-20', 'opacity-0');
    setTimeout(() => {
        toast.classList.add('translate-y-20', 'opacity-0');
    }, 2000);
}

function toggleExportMenu() {
    const menu = document.getElementById('exportMenu');
    menu.classList.toggle('hidden');
}

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
    const menu = document.getElementById('exportMenu');
    const btn = document.getElementById('exportMenuBtn');
    if (menu && btn && !menu.contains(event.target) && !btn.contains(event.target)) {
        menu.classList.add('hidden');
    }
});

// Suppress browser extension storage errors
window.addEventListener('error', function(e) {
    if (e.message && e.message.includes('storage')) {
        e.preventDefault();
        return true;
    }
});

window.addEventListener('unhandledrejection', function(e) {
    if (e.reason && e.reason.message && e.reason.message.includes('storage')) {
        e.preventDefault();
        return true;
    }
});
